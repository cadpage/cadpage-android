Quick getting started instructions for new developers.

Things you will need to install
1) Eclipse can be found at http://eclipse.org.  You want the Eclipse IDE for Java developers
2) Eclipse may or may not come bundled with a Java SDK.  If it does not, you will have to install one from somewhere
3) Apache Ant, which you can get from http://ant.apache.org
4) The Android SDK, which you can get from http://developer.android.com/sdk/index.html.

If you are just doing parsers, you won't be running much of the Android SDK, but you need the libraries to get project to compile.

The Cadpage project is hosted at http://code.google.com/p/cadpage/.  
The Source link will show you how to check out the source tree.  
The Issues link tracks all non-parser issues.  Parser issues are tracked separately.

Check out the main trunk source to a new local directory.
Open a command shell, switch to the local directory and enter
ant import
to import the test code
Import two new Eclipse projects, one for the cadpage directory and one for the cadpageTest directory.

You should now be able to compile and run the Cadpage app from the cadpage project.  And run the entire
Junit test suite in the cadpageTest project

So what is this import/export business all about.  The test project source lives in a standard src directory.
but this source contains thousands of sample 911 emergency pages of real calls to real emergencies at real 
addresses.  To keep those from showing up in standard Google searches, we do not commit this directory to 
the archive.  Instead we run it all through a rot13 cypher to a rot13-src directory which is committed to the
archive.  There are some Ant build files with targets to update these directories from the other.

import - copy any rot13-src changes to src
export - copy any src changes to rot13
stat   - perform an export followed by an svn stat.
update - perform an svn update followed by an import.


Work is needed in two general areas, one is the Android app UI and features, the other is the general text parsing library.  Since you expressed an interest in compilers and parsing, I'll go a bit further down the parsing library trail.

Everything in the net.anei.cadpage.parser package and subpackages can be compiled into a separate standalone parsing library jar file.  Which allows other applications to take advantage of all of this parsing magic.

What I need more than anything else is help cranking out next text parsers.  While these can get to be challenging at times, our biggest infrastructure successes come when they are brain dead trivial exercises that you can knock off in less than an hour.  I can usually pick out the brain dead simple ones, but even with these, there often turn out to be unexpected complications that can make them very challenging.

If you want to tackle some serious coding challenges, you can dive into the parsing support infrastructure.  These are pretty stable and seldom require additional enhancements.  And when they do I can easily take care of them.  Going into this stuff isn't all that helpful in the short run, the short run challenges are getting new parsers out.  But it would be extremely helpful in the long term, providing some degree of assurance that there is someone else who understands this stuff and could take over maintaining it when I and not around.

The parsing support infrastructure consists of...

MsgParser - the base class for all parser classes.  This is long with a fair number of support methods and classes, particularly the Parser subclass.  But is not all that complicated.

SmartAddressParser - base class for classes that require smart address parsing.  Which is the ability to identify an address from a data field that contains an address and something else.  This gets far more complicated than you would believe possible, supporting all kinds of special options that were added to support some special condition required for something somewhere.

FieldProgramParser - This is the crown jewel, designed to be a base class handling all parsers handling text pages with nicely delimited fields.  You pass a program string to the constructor that tells it which fields come in which order and if there are any keyword labels to check.  This gets compiled into a list of program steps which are executed in order to parse the text pages.  More often than not, there are some fields that require some special processing so there is a mechanism to override the standard field parsing class for each field type with one of your own.  And frequently there are exceptions the the standard strait forward field order, so there are provisions for keyword searches, optional fields, repeating fields, and conditional branches.

Infrastructure improvements wish list.  Like I said, this is pretty stable and satisfactory, but there are a couple items that would be nice to add.

Cached the compiled results.  FieldProgramParser pushes much of the work of interpreting and compiling the program string to a one time startup task.  In any normal computer environment, this would be sufficient.  But the Android system is a bit strange in that it arbitrarily decides when to kill your app to recover needed resources and starts it up again whenever it happens to be needed.  Add the fact that the secondary storage is really semiconductor memory that isn't that much slower than your primary memory and it makes a lot of sense to be able to cache the compiled program steps to secondary memory rather than compile them every time the class is loaded.

Assembler level programing.  Every now and then, I run across an odd text parsing arrangement that could be easily handled I could set up the processing steps exactly the way I wanted.  But there is no way to the compiler will produce exactly the steps I want in the specified order.  There is some need for some kind of assembly level coding convention that would allow the programmer to specify exactly what step is executed and what should happen if that step succeeds or fails.  This is not critical.  In every case where this would have been useful, I have been able to implement it using the conditional branch feature.  The results are more complicated than they needed to be, but they do get the job done.
 